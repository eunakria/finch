import fs from 'fs'
import path from 'path'

import Glob from 'glob'

interface Logger {
	info(...args: any[]): void
	error(...args: any[]): void
	warn(...args: any[]): void
}

type File = {
	path: string
	content: Buffer | string
}
type Options = {
	//logger: Logger | null
	sourceGlob: string | null
}

const relativize = (filePath: string, options: Options) => {
	if (!Glob.hasMagic(options.sourceGlob!)) {
		let dir = path.dirname(options.sourceGlob!)
		return path.relative(dir, filePath)
	} else {
		return filePath
	}
}

/**
 * One of the built-in transformers, which filters out files that haven't
 * changed since the last run.
 * 
 * @param criteria.renamer A function that takes a file path and returns
 *   its new path. Functions the same as the renamer transformer.
 *
 * @param criteria.target The output directory to compare old files to
 *   new ones. Functions the same as the target transformer.
 *
 * @param criteria.globSrc If this is set, instead of comparing on a
 *   file-by-file basis, the newest file in globSrc will be compared to
 *   each output file. This is useful for files that are generated by
 *   a bundler.
 * 
 * @param relativize Follow the same relativization rules that the target
 *   transformer uses. Defaults to true.
 */
function incremental(
	criteria: {
		renamer?: (file: string) => string
		target: string
		globSrc?: string
		relativize?: boolean
	}
) {
	return async function* incrementalTransformer(
		files: AsyncGenerator<File>, options: Options
	) {
		let doRelativize = criteria.relativize ?? true
		if (criteria.renamer === undefined) {
			criteria.renamer = file => file
		}

		let newestInSrc = null
		if (criteria.globSrc !== undefined) {
			newestInSrc = -Infinity
			for (let file of Glob.sync(criteria.globSrc)) {
				let inTime = fs.statSync(file).mtimeMs
				if (inTime > newestInSrc) {
					newestInSrc = inTime
				}
			}
		}

		for await (let file of files) {
			let relPath =
				doRelativize ? relativize(file.path, options) : file.path
			let outPath = path.join(
				criteria.target, criteria.renamer(relPath)
			)
			let inTime = newestInSrc ?? fs.statSync(file.path).mtimeMs
			let outTime = fs.existsSync(outPath)
				? fs.statSync(outPath).mtimeMs
				: -Infinity

			if (inTime > outTime) {
				yield file
			}
		}
	}
}

/**
 * One of the built-in transformers, which renames files from their
 * existing names per a provided function.
 */
function renamer(rename: (file: string) => string) {
	return async function* renamerTransformer(files: AsyncGenerator<File>) {
		for await (let file of files) {
			file.path = rename(file.path)
			yield file
		}
	}
}

/**
 * One of the built-in transformers, which flattens an input directory
 * tree into a single output directory.
 */
function flatten() {
	return async function* flattenTransformer(files: AsyncGenerator<File>) {
		for await (let file of files) {
			file.path = path.basename(file.path)
			yield file
		}
	}
}

/**
 * One of the built-in transformers, which outputs all the current files
 * to the output directory.
 * 
 * @param relativize If the input files are all from the same directory,
 *   remove the directory prefix from the output files. Defaults to true.
 */
function target(dir: string, doRelativize = true) {
	return async function* targetTransformer(
		files: AsyncGenerator<File>, options: Options
	) {
		fs.mkdirSync(dir, { recursive: true })
		for await (let file of files) {
			if (doRelativize) {
				file.path = relativize(file.path, options)
			}
			fs.writeFileSync(path.join(dir, file.path), file.content)
		}
	}
}

/**
 * One of the built-in transformers, which concatenates all the existing files.
 */
function concat(outputPath: string) {
	return async function* concatTransformer(files: AsyncGenerator<File>) {
		let content = Buffer.alloc(0)
		for await (let file of files) {
			let thisContent = typeof file.content === 'string'
				? Buffer.from(file.content)
				: file.content
			content = Buffer.concat([content, thisContent])
		}
		yield { path: outputPath, content }
	}
}

export default { incremental, renamer, flatten, target, concat }
