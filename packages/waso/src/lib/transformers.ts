import fs from 'fs'
import path from 'path'

import Glob from 'glob'

import { File, Options } from './waso'

const relativize = (filePath: string, options: Options) => {
	// Every glob up to the first star, sorted by the number of directories
	// they assert. This is used to determine the most directories that can
	// be trimmed off from the beginning of the file path.
	let globBases = options.sourceGlob
		.map(g => path.dirname(g).split('*')[0])
		.sort((a, b) =>
			Array.from(b.matchAll(/\//g)).length -
			Array.from(a.matchAll(/\//g)).length
		)

	for (let globBase of globBases) {
		if (filePath.startsWith(globBase)) {
			return path.relative(globBase, filePath)
		}
	}
	return filePath
}

/**
 * One of the built-in transformers, which reads files specified by a
 * glob pattern and outputs them to the output directory.
 */
function source(glob: string) {
	return async function* sourceTransformer(
		_files: AsyncGenerator<File>, options: Options
	) {
		options.sourceGlob.push(glob)
		for (let path of Glob.sync(glob, { nodir: true })) {
			yield {
				path,
				content: fs.readFileSync(path),
			}
		}
	}
}

/**
 * One of the built-in transformers, which filters out files that haven't
 * changed since the last run.
 * 
 * @param criteria.renamer A function that takes a file path and returns
 *   its new path. Functions the same as the renamer transformer.
 *
 * @param criteria.target The output directory to compare old files to
 *   new ones. Functions the same as the target transformer.
 *
 * @param criteria.globSrc If this is set, instead of comparing on a
 *   file-by-file basis, the newest file in globSrc will be compared to
 *   each output file. This is useful for files that are generated by
 *   a bundler.
 * 
 * @param criteria.relativize Follow the same relativization rules that the
 *   target transformer uses. Defaults to true.
 */
function incremental(
	criteria: {
		renamer?: (file: string) => string
		target: string
		globSrc?: string
		relativize?: boolean
	}
) {
	return async function* incrementalTransformer(
		files: AsyncGenerator<File>, options: Options
	) {
		let doRelativize = criteria.relativize ?? true
		if (criteria.renamer === undefined) {
			criteria.renamer = file => file
		}

		let newestInSrc = null
		if (criteria.globSrc !== undefined) {
			newestInSrc = -Infinity
			for (let file of Glob.sync(criteria.globSrc, { nodir: true })) {
				let inTime = fs.statSync(file).mtimeMs
				if (inTime > newestInSrc) {
					newestInSrc = inTime
				}
			}
		}

		for await (let file of files) {
			let relPath =
				doRelativize ? relativize(file.path, options) : file.path
			let outPath = path.join(
				criteria.target, criteria.renamer(relPath)
			)
			let inTime = newestInSrc ?? fs.statSync(file.path).mtimeMs
			let outTime = fs.existsSync(outPath)
				? fs.statSync(outPath).mtimeMs
				: -Infinity

			if (inTime > outTime) {
				yield file
			}
		}
	}
}

/**
 * One of the built-in transformers, which renames files from their
 * existing names per a provided function.
 */
function renamer(rename: (file: string) => string) {
	return async function* renamerTransformer(files: AsyncGenerator<File>) {
		for await (let file of files) {
			file.path = rename(file.path)
			yield file
		}
	}
}

/**
 * One of the built-in transformers, which flattens an input directory
 * tree into a single output directory.
 */
function flatten() {
	return async function* flattenTransformer(files: AsyncGenerator<File>) {
		for await (let file of files) {
			file.path = path.basename(file.path)
			yield file
		}
	}
}

/**
 * One of the built-in transformers, which outputs all the current files
 * to the output directory.
 * 
 * @param doRelativize If the input files are all from the same directory,
 *   remove the directory prefix from the output files. Defaults to true.
 */
function target(dir: string, doRelativize = true) {
	return async function* targetTransformer(
		files: AsyncGenerator<File>, options: Options
	) {
		let noFiles = true
		fs.mkdirSync(dir, { recursive: true })
		for await (let file of files) {
			noFiles = false
			if (doRelativize) {
				file.path = relativize(file.path, options)
			}

			fs.mkdirSync(
				path.dirname(path.join(dir, file.path)), { recursive: true }
			)
			fs.writeFileSync(path.join(dir, file.path), file.content)
			yield file
		}
		if (noFiles) {
			options.logger!.warn(`No files to write to ${dir}`)
		}
	}
}

/**
 * One of the built-in transformers, which concatenates all the existing files.
 */
function concat(outputPath: string) {
	return async function* concatTransformer(files: AsyncGenerator<File>) {
		let content = Buffer.alloc(0)
		for await (let file of files) {
			let thisContent = typeof file.content === 'string'
				? Buffer.from(file.content)
				: file.content
			content = Buffer.concat([content, thisContent])
		}
		yield { path: outputPath, content }
	}
}

export default { source, incremental, renamer, flatten, target, concat }
